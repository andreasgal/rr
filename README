Installation guide for rr
=========================


A) Hardware/software requirements
---------------------------------
rr has two mode of operation: 
(1) Plain Mode:
Requires a Linux kernel version 2.6.39 and higher.
To enable PEBS support for the hardware performance counters (HPC) a kernel
version >= 3.0 is required. Was developed under Ubuntu 11.04 & Ubuntu 12.04.
(2) Filter Mode (--filter_lib):
Requires kernel version 3.5 to support the seccomp-bpf filter, or Ubuntu 12.04 as 
it was backported to its 3.2. Developed and tested under Ubuntu 12.04.

Currently rr supports only recording and replaying of 32-bit x86 Linux processes.
It can be built and run as a 32-bit application on an x86_64 system; see below.

rr can run in a virtual machine that supports virtualization of performance
counters, such as VMWare Workstation 9. Installing the latest 32-bit
Ubuntu in a VM is an easy way to get rr working.

Building and running rr requires two additional libraries:

(1) libpfm-4.3.0:
http://sourceforge.net/projects/perfmon2/files/libpfm4/libpfm-4.3.0.tar.gz/download
On some distributions you can install the package:
Fedora 18: yum install libpfm

(2) libdisasm-dev:
http://sourceforge.net/projects/bastard/files/libdisasm/
On some distributions you can install the package:
Ubuntu >= 10.04: apt-get install libdisasm-dev

B) Building
-----------

rr is developed with the Eclipse CDT plugin. You can import the project directly into
Eclipse. Eclipse then generates a makefile which you can use to build the project.

C) Building on x86_64 systems
-----------------------------

On a 64-bit system, rr expects to find the 32-bit versions of those libraries
installed under $(HOME)/32bit, so you should download those libraries and build them
yourself.

To build the 32-bit version of libdisasm-dev, run configure like so:
./configure --prefix=$HOME/32bit --build=i686-pc-linux-gnu "CFLAGS=-m32" "CXXFLAGS=-m32" "LDFLAGS=-m32"

To build the 32-bit version of libpfm-4.3.0, edit config.mk and patch it like this:
@@ -65,8 +65,10 @@
 endif
 ifeq (mips,$(findstring mips,$(ARCH)))
 override ARCH=mips
 endif
+override ARCH=i386
+OPTIM=-O3 -m32
 
 ifeq (MINGW,$(findstring MINGW,$(SYS)))
 override SYS=WINDOWS
 endif
@@ -100,9 +102,9 @@
 
 #
 # Where should things (lib, headers, man) go in the end.
 #
-PREFIX=/usr/local
+PREFIX=$(HOME)/32bit
 LIBDIR=$(PREFIX)/lib
 INCDIR=$(PREFIX)/include
 MANDIR=$(PREFIX)/share/man
 DOCDIR=$(PREFIX)/share/doc/libpfm-$(VERSION).$(REVISION).$(AGE)
@@ -187,8 +189,9 @@
 LDCONFIG=true
 else
 DBG?=-g -Wall -Werror -Wextra -Wno-unused-parameter
 endif
+LDCONFIG=true
 
 CFLAGS+=$(OPTIM) $(DBG) -I$(SYSINCDIR) -I$(PFMINCDIR)
 MKDEP=makedepend
 PFMLIB=$(PFMLIBDIR)/libpfm.a

You will need to run rr with LD_LIBRARY_PATH=$HOME/32bit/lib.

D) Usage
--------

Before calling either the recorder or the replayer make sure that address space
randomization is disabled. You can do this by e.g., with the following command:

sysctl -w kernel.randomize_va_space=0

Also, we need to be able to write to /proc/$pid/mem. On Ubuntu (or any other kernel with
the ptrace_scope_feature), this requires the following command:

sysctl -w kernel.yama.ptrace_scope=0

Typing rr --record /path/to/binary invokes the recorder. The recorder
creates a path in the current directory which contains the trace file(s).
To replay the application, type rr --replay /path/to/trace.  

Other command line options:
[--filter_lib=<path>] : Only for kernels >= 3.5; this installs a wrapper for several system 
calls (look at share/wrap_syscalls.c) to speed up their handling and save on the ptrace()
context switch. The wrapper is compiled as a shared object called 'libwrap_syscalls.so' (as
part of rr compilation process) and can be found in the rr executable directory.

Debug command line options:
[--dump_on=<syscall|-signal>] : dump the entire memory to file every time the system call 
numbered <syscall> is encountered or a signal numbered by <signal> is encountered. The
negation if signal is required to distingish between syscalls and signals of the same number.
example: --dump_on=79 : dumps all memory every time gettimeofday is entered. --dump_on=-17: 
dumps all memory every time  signal SIGCHLD is recieved.
[--dump_at=<time>] : dump the entire memory at global time <time>
[--checksum={on-syscalls,on-all-events}|<from-time>] : For record: calculated a checksum 
of the entire memory either on every event (on-all-events) or on every syscall (on-syscalls) 
or starting from global time <from-time>. Fore replay: verifies the calculated checksums,
should be run with same arguments as the record.

Note that talking to particular kernel drivers (by ioctl(...)) requires the
rr to have knowledge about what the driver is doing. For example, if you
record GUI applications that make use a grapphics driver with 3d-support
rr will fail. If you're using NVidia binary drivers, removing the
xorg-x11-drv-nvidia-libs package will avoid this problem.

Also, it is advised to turn off any CPU frequency scaling capabilities, such as Intel Speed Step. 
This can be achieved by either turning it off in the BIOS or by disabling it in the 
kernel, e.g. by setting the CPU governor to 'performance'. If neither of these solutions 
is feasible, rr and its child processes should be pinned on a certain core, e.g. by 
running rr with:

taskset 0x1 rr <options>

or, in the case of a CPU that is able to run multiple threads on one core in parallel, such
as Intel CPUs with Hyperthreading capabilities, it is better to use:

taskset 0x3 rr <options>

Otherwise, due to frequent context switches between rr and the traced process, the different
cores will often scale down their frequency which can lead to slowdowns of up to 2x.

